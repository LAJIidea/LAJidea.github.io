<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kingkiller’s blog</title>
    <link>https://lajidea.github.io/</link>
    <description>Recent content on kingkiller’s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Jan 2021 18:00:58 +0800</lastBuildDate><atom:link href="https://lajidea.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>String字符串拼接比较</title>
      <link>https://lajidea.github.io/post/string/</link>
      <pubDate>Thu, 28 Jan 2021 18:00:58 +0800</pubDate>
      
      <guid>https://lajidea.github.io/post/string/</guid>
      <description>StringBuilder做字符串拼接高效的原因 1.与String相比 通过分析源码,发现两者底层都是用一个数组来存储字符
public final class String implements java.io.Serializable,Comparable&amp;lt;String&amp;gt;,CharSequence{ /** The value is used for character storage */ private final char value[]; ==这里需要注意,StringBuilder本身并没有定义value数组,我们需进入其父类AbstractStringBuilder中,可以发现用来存储字符的数组value.==
/** * The value is used for character storage */ char value[]; 可以发现,String底层的数组是用final修饰的,是一个数组常量,而StringBuilder底层用来接收存储字符的数组是一个变量.所以前者在创建之后是没法更改,而后者可以
这里我们看一段代码
package reason; public class Test { public static void main(String[] args){ String str = &amp;#34;不变&amp;#34;; System.out.println(str); str = &amp;#34;变了&amp;#34; System.out.println(str); } } 结果却是str从最初的&amp;quot;不变&amp;quot;,到后来的&amp;quot;变了&amp;quot;,字符串str发生了改变,但String底层的数组不是常量吗?为什么值会发生改变?
其实在内存中String发生了这样的变化: 在内存中,我们先创建了一个str对象,并且赋值&amp;quot;不变&amp;quot;,之后其实并不是在原有创建的str对象上作更改,而是又创建了一个新的字符串对象,并且赋值变了,把之前的引用类型变量str指向新创建的对象,而之前创建的对象处于等待被回收的状态,如果没有被调用,就会被JVM提供的垃圾回收机制给回收掉.
到这里我们可以发现,之所以String本身做字符串拼接执行速度慢,是因为其本质上是一个不断创建新对象,并且回收旧对象的过程.那说到StringBuilder和StringBuffer,它们创建的对象是变量,对变量操作就是对对象操作,中间不存在对象的创建和回收,所以速度比String快
那真的是这样吗?我们进入到StringBuilder封装后的源代码,查看其append方法
@Override public StringBuilder append(String str) { super.</description>
    </item>
    
    <item>
      <title>2021春节档前瞻</title>
      <link>https://lajidea.github.io/post/firstflimreview/</link>
      <pubDate>Thu, 28 Jan 2021 17:09:18 +0800</pubDate>
      
      <guid>https://lajidea.github.io/post/firstflimreview/</guid>
      <description>2021年的春节档前瞻，经历了惨淡的2020年，内地电影市场准备在2021年开春就做出冲击</description>
    </item>
    
    <item>
      <title>spring</title>
      <link>https://lajidea.github.io/post/firstblog/</link>
      <pubDate>Thu, 28 Jan 2021 16:07:02 +0800</pubDate>
      
      <guid>https://lajidea.github.io/post/firstblog/</guid>
      <description>spring的学习与介绍
1.Spring 简介:
 2002,首次推出了Spring框架的雏形:interface21框架 2004年3月24发布了1.0正式版 Rod Johnson,SpringFramework创始人.(悉尼大学音乐学博士)  1.IOC导论 先看一下在没有使用spring框架时,我们是怎样开发的.这里使用一个dao层和一个service层做示范,Dao层中有一个userDao类,提供了一个获取用户信息的方法. 在service层中调用Dao层,用户看不见Dao层的操作.
1.userDao接口 package com.kingkiller.dao; public interface UserDao { void getUser(); } 2.UserDaoImpl实现类 package com.kingkiller.dao; public class UserDaoImpl implements UserDao { public void getUser(){ System.out.println(&amp;#34;默认获取用户的数据&amp;#34;); } } 3.UserService业务接口 package com.kingkiller.service; public interface UserService { void getUser(); } 4.UserServiceImpl业务实现类 package com.kingkiller.service; import com.kingkiller.dao.UserDao; import com.kingkiller.dao.UserDaoImpl; public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 5.</description>
    </item>
    
  </channel>
</rss>
